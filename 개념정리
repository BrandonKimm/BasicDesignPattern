스프링에서 자주 사용되는 디자인 패턴 
    자바의 객체지향스러운 특징(캡슐화/상속/추상화/다형성)을 이용해서  객체지향스럽게 설계(SOLID)하는
    실제 현장에서 쓰이고 효율적인 설계방식들을 메뉴얼화 한 것이 디자인패턴이다.
    요리(자바 웹어플리케이션) : 요리도구(캡/상/추/다) : 요리도구의 사용법(SOLID) : 요리레시피(디자인패턴) 

1. Adapter Pattern 
    서로 다른 두 인터페이스 사이에 통신이 가능하게 하는 느낌 전에 JDBC 같은 케이스 OCP를 활용한 디자인패턴
    실제 수행되는 객체와 클라이언트가 필요한 서비스와 서비스가 수행되는 실제객체 사이에 어댑터를 두고 
    ==> 객체를 속성(멤버변수)으로 만들어서 참조하는 디자인 패턴
    ==> 기존클래스의 소스코드를 전혀 수정하지 않고 타겟인터페이스에 맞춰서 동작을한다.
    
2. Proxy Pattern 
    실제서비스를 수행하는 실제객체를 생성을 바로하는게 하지않고 프록시(대리인)를 이용해 실질적인 메소드가 호출될때 객체도 생성 해버리는 방식
    실제이미지를 보여주기 이전에 미리보기 보여주는 느낌! 웹서버도 마찬가지 실제 DB나 로직이 담긴 서비스를 수행안하고 정적인데이터 트래픽 해결
    ==> 인터페이스를 중간에 두고 각종 타이어들을 교체해줘도 영향없던 자통차 예시처럼 OCP와 DIP를 활용한 디자인패턴
    ==> 흐름만 제어할 뿐 실제객체에서 반환된 결과값을 절대 가공하지않는다.
    
3. Decorator Pattern
    Proxy Pattern + 장식(Decoration) = Decoration Pattern
    ==> 메서드호출의 반환값에 변화를 주기 위해 중간에 장식자(Decorator)를 두는 패턴

4. Singleton Pattern
    클래스의 인스턴스, 즉 객체를 하나만 만들어서 전역으로 사용하는 패턴
    레플릭션을 이용해서 생성을 한다거나 멀티스레드경우에 생기는 문제라거나 더 많다 그 만큼 너무 많이 쓰이는 패턴이니 잘 숙지하기! 
    정적참조변수와 객체반환정적메소드 그리고 private 생성자 세 박자를 잘 기억

5. Template Method Pattern
    상위클래스를 통해 반복되는 코드 제거 및 DIP을 활용하는 패턴
    ==> 상위클래스의 견본메소드에서 하위클래스가 오버라이딩한 메소드를 호출하는 패턴
    메소드의 존재와 내용까지 강제할 수도 있고, 하위클래스에게 오버라이딩을 강제하게 할 수도 있고, 하위클래스에서 메소드를 존재여부와 내용을 선택하게 할 수도 있다. 

6. Factory Method Pattern
    ==>팩토리 메소드 패턴을 사용하는 이유는 클래스간의 결합도를 낮추기 위한 패턴
    결합도라는 것은 간단히 말해 클래스의 변경점이 생겼을 때 얼마나 다른 클래스에도 영향을 주는가
    팩토리 메소드 패턴을 사용하는 경우 직접 객체를 생성해 사용하는 것을 방지하고 서브 클래스에 위임함으로써 보다 효율적인 코드 제어를 할 수 있고 의존성을 제거한다.

7. Strategy Pattern
    ==> 변화되는 것을 찾은 후 이 클래스를 캡슐화 하는 것 
    ==> OCP와 DIP를 활용해 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴
    상위클래스 로봇에서 공격() 이라는 메소드를 상속받아서 오버라이딩 각각각 로봇들이 구현하게되면 각 로봇의 메소드내용이 중복될수도있고 일관적으로 관리가 안될 수 있다
    그러니 각 로봇들이 행동할 수 있는 공격방식 이동방식 등등.. 을 인터페이스로 구현하고 로봇에서는 각종 방식들을 집약관계로 맺는다 
    ==> 새로운 각종방식들이 변경되고 수정되어도 인터페이스가 방화벽같은 역할을 하게 됨으로서 로봇클래스에서는 변화가 생기지 않는다! 
            >> 로봇에 공격행위인터페이스를 인자로 넣어서 각 로봇인스턴스에 공격행위를 정의하는 예제 
    자주쓰이는 패턴이니 자세히 구현해본 전략패턴예제를 참고하기 reference : https://walbatrossw.github.io/oop/2018/07/27/design-pattern-01-strategy-patterns.html


8. Template Callback Pattern
    ==> OCP DIP를 활용한 전략패턴의 일종이고 DI(의존성주입)에서 자주쓰이며 전략을 익명 내부 클래스로 구현한 패턴이다.
    전략패턴 자체가 클라이언트가 특정행위(전략)을 하는것을 직접 주입해서 사용할 수 있다는 장점인데 그것을 익명으로 처리해버린 거지
    근데 클라이언트가 행위를행하는 인스턴스(군인)에 각각 주입하지않고 군인클래스에서 내부익명클래스로 구현 *솔직히 잘 모르겠음 ㅎㅎ 

9.그 외 나중에는 다 알아야 할 다양한 디자인패턴 카테고리와 종류들
    9-1) 생성패턴 : 객체 생성에 관련된 패턴으로 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램에 영향을 크게 받지 않도록 유연성을 제공한다.
        (1) 추상 팩토리(Abstract Factory) : 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
        (2) 빌더(Builder)
        (3) 팩토리 메서드(Factory Method) : 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴
        (4) 프로토 타입(Prototype)
        (5) 싱글턴(Singleton) : 전역 변수를 사용하지 않고, 객체를 하나만 생성하도록 하며, 생성된 객체를 어디서든 참조할 수 있도록 하는 패턴
    9-2) 구조패턴 : 클래스나 객체를 조합해 더 큰 구조로 만드는 패턴이다. 예를 들어 서로 다른 인터페이스를 2개 지닌 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.
        (1) 어댑터(Adaptor)
        (2) 브리지(Bridge)
        (3) 컴퍼지트(Composite) : 여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴
        (4) 데커레이터(Decorator) : 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴
        (5) 퍼사드(facade)
        (6) 플라이웨이트(Flyweight)
        (7) 프록시(Proxy)
    9-3) 행위패턴 : 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴이다. 가령 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다.
        (1) 책임 연쇄(Chain of Responsibility)
        (2) 커맨드(Command) : 실행될 기능을 캡슐화함으로써 주어진 여러기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴
        (3) 언터프리터(Interpreter)
        (4) 이터레이터(Iterator)
        (5) 미디에이터(Mediator)
        (6) 옵저버(Observer) : 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴
        (7) 스테이트(State) : 객체의 상태에 따라 객체의 행위 내용을 변경해주는 패턴
        (8) 스트래티지(Strategy) : 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
        (9) 템플릿 메서드(Template Method) : 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
        (10)비지터(Visitor)
